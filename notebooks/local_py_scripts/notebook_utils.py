# python module... 
import pandas as pd
import json
from geojson import Feature, FeatureCollection, Polygon, Point

import numpy as np
import gmsh 


def extract_fault_data(fault):
#  This extracts function is used to extract fault data from files generated by ESFM 
#
#
# Extract nodes
    nodes = pd.DataFrame({
        'latitude': pd.concat([fault['lat1'], fault['lat2'], fault['lat3']]),
        'longitude': pd.concat([fault['lon1'], fault['lon2'], fault['lon3']]),
        'depth': pd.concat([fault['depth1'], fault['depth2'], fault['depth3']])
        }).drop_duplicates().reset_index(drop=True)
# Convert nodes DataFrame to numpy array
    node_array = nodes.to_numpy()
# Create a mapping from node to index
    node_mapping = {tuple(node): index for index, node in nodes.iterrows()}
    
# Create an array of triangles with node indices
    cells = np.array([
        [
            node_mapping[(fault.iloc[i]['lat1'], fault.iloc[i]['lon1'], fault.iloc[i]['depth1'])],
            node_mapping[(fault.iloc[i]['lat2'], fault.iloc[i]['lon2'], fault.iloc[i]['depth2'])],
            node_mapping[(fault.iloc[i]['lat3'], fault.iloc[i]['lon3'], fault.iloc[i]['depth3'])]
        ]
        for i in range(len(fault))
    ])
    # nnodes = len(nodes_array)
    # ncells = len(cells)
    
    return node_array,cells
#######################################################################################
#
# Function to generate a planar mesh using GMSH
#   Flength :       Length of the fault [m]
#   Fwidth:         Down dip with of fault [m]
#   Fdip:           Fault dip [radians] 
#   lcar:           cell size on fault [m]
#   file_name:      two output file names are generated file_name.msh and file_name.vtk
def mesh_planar_fault(Flength,Fwidth,Fdip,lcar,file_name):
    gmsh.initialize()
    gmsh.clear() 
# add points delineating the top (fault trace) and bottom of the fault 
    gmsh.model.geo.addPoint( 0, 0, 0, lcar, 0)
    gmsh.model.geo.addPoint( 0, Flength, 0, lcar, 1)
    gmsh.model.geo.addPoint( Fwidth*np.cos(Fdip), Flength, -Fwidth*np.sin(Fdip), lcar, 2)
    gmsh.model.geo.addPoint( Fwidth*np.cos(Fdip), 0, -Fwidth*np.sin(Fdip), lcar, 3)
# joint the points together to turn the fault into segments that will be meshed
    gmsh.model.geo.addLine(0, 1, 0)
    gmsh.model.geo.addLine(1, 2, 1)
    gmsh.model.geo.addLine(2, 3, 2)
    gmsh.model.geo.addLine(3, 0, 3)
# curve loop
    gmsh.model.geo.addCurveLoop([0, 1, 2, 3], 1)
    gmsh.model.geo.addPlaneSurface([1], 1)

    gmsh.model.geo.synchronize()
    gmsh.model.mesh.generate(3)   # put as 3 as we are generating a 3d mesh

# write results to file 
    gmsh.write(file_name+".vtk")   
    gmsh.write(file_name+".msh")      
    
# Finalize Gmsh
    gmsh.finalize()      
#######################################################################################
def remesh_fault(points,cells,target_edge,file_name):
#
# Function to remesh fault defined by points (i.e. nodes) and cells
#   containing cells with a length defined by target_edge.
#   the new mesh is written to file with the name file_name.vtk and file_name.msh
#    
# Initialize the Gmsh API
    gmsh.initialize()
    gmsh.clear() 

# Suppress output to keep the notebook clean
    gmsh.option.setNumber("General.Terminal", 1)
# Add nodes
    for i, node in enumerate(points):
        gmsh.model.geo.addPoint(node[0], node[1], node[2], 0, i + 1)

# Add elements (triangles)
    for i, triangle in enumerate(cells):
        gmsh.model.geo.addLine(triangle[0] + 1, triangle[1] + 1, i * 3 + 1)
        gmsh.model.geo.addLine(triangle[1] + 1, triangle[2] + 1, i * 3 + 2)
        gmsh.model.geo.addLine(triangle[2] + 1, triangle[0] + 1, i * 3 + 3)
        gmsh.model.geo.addCurveLoop([i * 3 + 1, i * 3 + 2, i * 3 + 3], i + 1)
        gmsh.model.geo.addPlaneSurface([i + 1], i + 1)
# Reconstruct geometry from the mesh
    gmsh.model.mesh.createGeometry()
# Synchronize Gmsh model
    gmsh.model.geo.synchronize()
# Define a size field for adaptive refinement
    field_id = gmsh.model.mesh.field.add("MathEval")
    gmsh.model.mesh.field.setString(field_id, "F", np.array2string(target_edge))  # Desired element size, adjust as needed
    gmsh.model.mesh.field.setAsBackgroundMesh(field_id)
# Synchronize the CAD entities with the Gmsh model
    gmsh.model.geo.synchronize()
# remesh 
    gmsh.model.mesh.generate(2)
# Merge nodes to remove duplicates
    gmsh.model.mesh.optimize("Netgen")
    gmsh.model.mesh.removeDuplicateNodes()    
# write results to file 
    gmsh.write(file_name+".vtk")   
    gmsh.write(file_name+".msh")    
# Finalize Gmsh
    gmsh.finalize()    

#######################################################################################
#
# Function to extract nodes and cells from a gmsh file 
#
def extract_mesh(file_name):
# Initialize Gmsh
    gmsh.initialize()

# Open the mesh file
    gmsh.open(file_name)
    entities = gmsh.model.getEntities(2)
    

    # extract nodes from mesh
    nodeTags, nodeCoords, _ = gmsh.model.mesh.getNodes()
    print('number of nodes     ',len(nodeTags))

    elemTypes, elemTags, elemNodeTags = gmsh.model.mesh.getElements(2)
    x = np.zeros(len(nodeTags),dtype=float)
    y = np.zeros(len(nodeTags),dtype=float)
    z = np.zeros(len(nodeTags),dtype=float)


    for i in range(0,len(nodeTags)):
        inode = int(nodeTags[i]-1)   # need to take 1 off so tags relate to 
        x[inode] = nodeCoords[i*3]
        y[inode] = nodeCoords[i*3+1]
        z[inode] = nodeCoords[i*3+2]

        
    # extract cells from mesh 
    
    # find out number of triangular cells 
    nncells = 0
    for e in entities:
        dim = e[0]
        tag = e[1]
        if dim == 2 :
        # Get the mesh elements for the entity (dim, tag):
            elemTypes, elemTags, elemNodeTags = gmsh.model.mesh.getElements(dim, tag)
        # Number of mesh nodes and elements:
            numElem = sum(len(i) for i in elemTags)
            nncells = nncells+numElem
    
    print('number of elements    ',nncells)
    
    cells = np.zeros((nncells,3),dtype=int)
    icell = 0
    for e in gmsh.model.getEntities(2):  # For each surface in the model:
        # Retrieve the surface tag
        s = e[1]
        elemTypes, elemTags, elemNodeTags = gmsh.model.mesh.getElements(2, s)
        ncell_local = int(len(elemNodeTags[0])//3)
        cells[icell:icell+ncell_local][:] = np.reshape(elemNodeTags[0],(ncell_local,3)) 
        icell = ncell_local+icell
    cells = cells-1   # need to take 1 away from cells to convert tags to node indices  
    # Finalize Gmsh (but keep data for further processing)
    gmsh.finalize()
    
    return  x,y,z,cells

#######################################################################################
def tri_dist(triangles):
#
# Function to calculate the distance along the edges of triangle
#    
    dist = []
    for tri in triangles:
        p1,p2,p3 = tri
        edge1 = np.linalg.norm(p1 - p2)
        edge2 = np.linalg.norm(p2 - p3)
        edge3 = np.linalg.norm(p3 - p1)
        dist.append(edge1)
        dist.append(edge2)
        dist.append(edge3)
    # mean_dist = np.mean(dist)
    return  dist    
#
# Function to calculate area of triangle 
#
def tri_area_3d(triangles):
    # Extract x, y, and z coordinates
    x1, y1, z1 = triangles[:, 0, 0], triangles[:, 0, 1], triangles[:, 0, 2]
    x2, y2, z2 = triangles[:, 1, 0], triangles[:, 1, 1], triangles[:, 1, 2]
    x3, y3, z3 = triangles[:, 2, 0], triangles[:, 2, 1], triangles[:, 2, 2]
    
    # Compute vectors AB and AC
    AB = np.stack([x2 - x1, y2 - y1, z2 - z1], axis=-1)
    AC = np.stack([x3 - x1, y3 - y1, z3 - z1], axis=-1)
    
    # Compute the cross product AB x AC
    cross_product = np.cross(AB, AC)
    
    # Compute the area as half the magnitude of the cross product
    area = 0.5 * np.linalg.norm(cross_product, axis=-1)
    return area

#######################################################################################
def check_tri(pt,triangle):
#  Function to check if pt is inside triangle 
#    The cell and point are projected onto a surface consequently a 0 is added for the depth on all the elements 
#    pt is the x,y position for the nucleation position 
#    triangle : the x,y nodes to the element that is being tested    
    v0 = np.append(triangle[0,:],0)   
    v1 = np.append(triangle[1,:],0)
    v2 = np.append(triangle[2,:],0)
    pt = np.append(pt,0)
    area_tri = np.cross(v1-v0,v2-v0)[2]
    u3 = np.cross(v1-v0,pt-v0)/area_tri
    v3 = np.cross(pt-v0,v2-v0)/area_tri
    u = u3[2]
    v = v3[2]
    return u,v

#######################################################################################
def calc_time(pt,triangle,vel):
#
#  Function to calculate traveltime to nodes when point is inside triangle 
#    
    t = np.zeros((3,))
    for i in range(len(triangle)):
        d = np.linalg.norm(pt-triangle[i,:])   # calculate distance to the triangle nodes
        t[i] = d/vel

    return t

#
#######################################################################################
def assign_nucleation_location(nuc_x,nuc_y,x,y,z,cells,cell_vel):
    """
    assign initial rupture time around nucleation location and set all other nodes to -200
    
    :nuc_x,nuc_y: floats giving location of earthquake nucleation 
    :x,y,z: float arrays for nodes of the mesh 
    :cells: no of cellsx3 integer array containing the linke between nodes and cells 
    :cell_vel:  is float array with a length equal to the no of 
    
    """
    inf = -200;  
    nuc_pt = [nuc_x,nuc_y]
    # set up inital time array
    itime = inf*np.ones(len(x),dtype=float)    
    
    # check that nucleation point is within array 
    if (nuc_x > np.max(x)) or (nuc_y > np.max(y)):
        print('Error: Nucleation located outside of fault domain')
    for i in range(len(cells)):
        id = cells[i]
        triangle = np.vstack((x[id], y[id])).T
    # triangle = np.vstack((x[id], y[id],z[id])).T

        u,v = check_tri(nuc_pt,triangle) 
        if u >= 0 and v >= 0 and v+u <= 1 and v+u >= 0:
            print('Source is in cell',i)
            t = calc_time(nuc_pt,triangle,cell_vel[i])
            print('Initial travel time on starting cell edges:',t)
            on_node = False
            for j in range(0,3):
                if t[j] < 10**-5:
                    itime[id[j]] = 0.0
                    on_node = True
                    print('Source located at a single node')
            if on_node:
                break
            for j in range(0,3):
                itime[id[j]] = t[j]
            break
    if i == len(cells)-1:
        print('ERROR: no cell with source inside detected')
    return itime




#######################################################################################
#
# subroutine for writing data to a vtk file 
#
def write_vtk(file_name,lpoints,lcells,lvel,ltime,surface_nodes=None):
    lnnodes = len(lpoints)
    lncells = len(lcells)
    lx = lpoints[:,0]
    ly = lpoints[:,1]
    lz = lpoints[:,2]
        
    f = open(file_name,"w")
    f.write("# vtk DataFile Version 2.0 \n")
    f.write("Time \n")
    f.write("ASCII \n")
    f.write("DATASET POLYDATA \n")
    f.write("POINTS "+str(lnnodes)+" double \n")
    for i in range(0,lnnodes):
        f.write('%f %f %f \n' % (lx[i], ly[i], lz[i]))
    f.write(' \n')
    f.write('%s %d %d \n' % ("POLYGONS ",lncells,lncells*4))
    for i in lcells:
        f.write('3 %d %d %d \n' % (i[0],i[1],i[2]))
    f.write(' \n')

    ## cell data : set velocity on each cell 
    f.write('CELL_DATA %d \n' % (lncells))
    field_name = "vel"
    f.write("SCALARS " + field_name + " double 1 \n")
    f.write("LOOKUP_TABLE default \n")
    for i in range(lncells): #ncells):
        f.write('%f  \n' % (lvel[i]))
    f.write(' \n')

    ## node data : initial travel time (if not known given negative value)
    f.write('POINT_DATA %d \n' % (lnnodes))
    field_name = "time"
    f.write("SCALARS " + field_name + " double 1 \n")
    f.write("LOOKUP_TABLE default \n")
    for i in range(0,lnnodes):
        f.write('%f  \n' % ltime[i])
    f.write(' \n')

    if surface_nodes is not None:
    ## node data : surface nodes 
        # f.write('POINT_DATA %d \n' % (lnnodes))
        field_name = "surface"
        f.write("SCALARS " + field_name + " int 1 \n")
        f.write("LOOKUP_TABLE default \n")
        for i in range(0,lnnodes):
            f.write('%d  \n' % surface_nodes[i])
        f.write(' \n')


    f.close()
    
    
    
def update_inputfile(file_path, updates):
    """
    Update specific values in a NAMELIST inputfile.

    :param file_path: Path to the inputfile.
    :param updates: Dictionary of updates where keys are variable names and values are the new values.
    """
    # Read the file
    with open(file_path, 'r') as file:
        lines = file.readlines()
    
    # Process lines to modify values
    in_namelist = False
    updated_lines = []
    
    for line in lines:
        stripped_line = line.strip()
        if stripped_line.startswith('&'):
            in_namelist = True
        
        if in_namelist:
            # Look for variable assignments
            # for var in updates.keys():
            for var, value in updates.items():

                if stripped_line.startswith(var + '='):
                    # Special case for .true. and .false.
                    if value == '.true.' or value == '.false.':
                        formatted_value = value
                     # Check if value is a string and add quotes if necessary
                    elif isinstance(value, str):
                        formatted_value = f'"{value}"'
                    else:
                        formatted_value = str(value)
                    # Replace the variable's value
                    # updated_line = f"{var}={updates[var]}"
                
                    # Replace the variable's value
                    updated_line = f"{var}={formatted_value}"
                    
                    # Condition for last variable in Namelist block
                    if '/' in stripped_line:
                        updated_lines.append(updated_line + '  /\n')    
                    # Condition for variable not at end of Namelist block    
                    else:    
                        updated_lines.append(updated_line + ',\n')
                    break
            else:
                # If no variable matched, keep the line as is
                updated_lines.append(line)
        else:
            updated_lines.append(line)
        
        if stripped_line.startswith('# '):
            in_namelist = False
    
    # Write the updated content back to the file
    with open(file_path, 'w') as file:
        file.writelines(updated_lines)
        
        
def write2gis(nodes,cells,slip,time,file_name):
#   Script to create a GeoJSON file with the fault mesh, slip and 
#       rupture velocity that can be read by QGIS
#   nodes:      mesh nodes save in numpy array
#   cells:      numpy interger array linking nodes to cells
#   slip:       numpy array with the slip relating to each cell
#   time:       numpy array with the rupture time on the nodes 
#   file_name:  file name that will have the GeoJSON format

    py_nodes = nodes.tolist()
    py_cells = cells.tolist()
    py_slip = slip.tolist()
    py_time = time.tolist()
    # Create features for each cell with slip value
    cell_features = []
    i = 0 
    for cell in py_cells:
        node1, node2, node3 = cell
        # Create the polygon representing the cell
        polygon = Polygon([[
            (py_nodes[node1][0], py_nodes[node1][1], py_nodes[node1][2]),
            (py_nodes[node2][0], py_nodes[node2][1], py_nodes[node2][2]),
            (py_nodes[node3][0], py_nodes[node3][1], py_nodes[node3][2]),
            (py_nodes[node1][0], py_nodes[node1][1], py_nodes[node1][2])  # Close the polygon loop
        ]])
        
        # Add a feature for each cell with slip as an attribute
        feature = Feature(geometry=polygon, properties={"slip": py_slip[i]})
        i = i+1
        cell_features.append(feature)

    # Create features for each node with rupture time value
    node_features = []
    i = 0 
    for node in py_nodes:
        lon, lat, d = node
        point = Point((lon, lat,d))
        feature = Feature(geometry=point, properties={"time": py_time[i]})
        i = i+1
        node_features.append(feature)

    # Combine cell and node features into one FeatureCollection
    features = cell_features + node_features
    feature_collection = FeatureCollection(features)

    # Save to a GeoJSON file
    with open(file_name, "w") as f:
        json.dump(feature_collection, f)

    print("GeoJSON file created with name ",file_name)